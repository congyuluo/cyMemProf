# Dev version
dev_version = '0.1'

# c altered source path
c_altered_loc = 'c_altered/'
c_processed_loc = 'c_preprocessed/'
c_source_loc = 'c_src/'

# c profiled result path
c_profiled_loc = 'c_profiled/'

# c altered suffix
c_processed_suffix = '_processed.c'
c_altered_suffix = '_altered.c'
c_inst_counting_suffix = '_inst_counting.c'

# c wrapper funcs
c_wrapper_funcs = [
    (r'malloc', 'mallocWrapper'),
    (r'calloc', 'callocWrapper'),
    (r'valloc', 'vallocWrapper'),
    (r'aligned_alloc', 'aligned_allocWrapper'),
    (r'realloc', 'reallocWrapper'),
    (r'free', 'freeWrapper')
]

# c ptr_deref func name
c_ptr_deref_func = 'logAccess'

# c funcCall param func name
c_funcCall_param_func = 'logExtParam'

# c scope enter & exit func names
c_scope_enter_func = 'logScopeEnter'
c_scope_exit_func = 'logScopeExit'
c_return_func = 'logReturn'

# c dynamic instruction counting scope enter & exit func names
c_inst_scope_enter_func = 'logInstScopeEnter'
c_inst_scope_exit_func = 'logInstScopeExit'
c_inst_return_func = 'logInstReturn'

# Exit function name
c_exit_func = 'atExitFunc'

# Inst counting at-exit func name
c_inst_exit_func = 'instAtExitFunc'

# At-exit function name
c_inst_init_func = 'base_check'


# Types of runtime results
c_alloc_type = set(['MLOC', 'CLOC', 'VLOC', 'ALOC'])
c_deref_type = set(['DREF', 'PRAM'])
c_realloc_type = set(['REAL'])
c_free_type = set(['FREE'])
c_generic_type = set(['SENT', 'SEXT', 'RETN', 'EXIT'])

# Set of all wrapper functions
c_wrapperFunc_set = set([i[1] for i in c_wrapper_funcs] +
                        [c_ptr_deref_func, c_funcCall_param_func, c_scope_enter_func, c_scope_exit_func, c_return_func, c_exit_func])

# At-exit function string
c_atexit_func = '\n   // Register the function to free allocList prior to exit\n   if (atexit(' + c_exit_func + ') != 0) {\n      fprintf(stderr, "cyMemProfiler: Failed to register the exit function.");\n      return 1;\n   }\n'

# Inst counting at-exit function string
c_int_atexit_func = '\n   // Injected at-exit function for exporting and freeing data runtime data\n   if (atexit(' + c_inst_exit_func + ') != 0) {\n      fprintf(stderr, "cyMemProfiler: Failed to register the exit function.");\n      return 1;\n   }\n'

# Inst counting init function
c_inst_counting_init_func = '\n   // Init instruction counting module\n   ' + c_inst_init_func + '();\n'

# auto-generation notes
c_auto_gen_notes = f"// This file is auto-generated by cyMemProfiler\n// Version: {dev_version}\n\n"

# resulting source includes
c_probe_includes = [
    '#include "wrapperFuncs.h"'
]

# resulting inst counting source includes
c_inst_probe_includes = {
    '#include "instProf.h"'
}

# Inter-module variables
includes = []


